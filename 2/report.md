# Лабораторная работа 2

## Техническое задание
1. В среде V-REP необходимо реализовать построение карты окружающего робота пространства при помощи SLAM. Требуется использовать карту, полученную в результате работы № 1.
2. Необходимо разработать программу, с помощью которой робот может передвигаться до точки, назначенной пользователем, по готовой карте.
## Реализация
В работе использовалась библиотека BreezySlam, которая реализует алгоритм RMHC SLAM (Random-Mutation Hill-Climbing SLAM). Для вывода карты на экран использовался RoboViz.
1) Подготовка сцены и робота
Была скопирована сцена из работы № 1. На крышу робота был добавлен лидар Hokuyo 04LX UG01.
![Pioneer с лидаром Hokuyo](/pics/pio.png)
Лидар через определенное время собирает данные о близлежащих объектах (684 значения - расстояния до препятствий). Данные обрабатываются прямо в среде V-REP, запаковываются и отправляются как строка. Для большей точности алгоритма, есть возможность дополнить расстояния одометрией. В данной ситуации одометрия рассматривается как угол поворота колеса в радианах.
2) Описание взаимодействия с BreezySlam
Скрипт Python получает данные по имени сигнала, затем обрабатывает их (необходимо перевести значения расстояний из метров в сантиметры) и передает объекту SLAM. объект делает изменения на карте, а также вычисляет новые координаты $(x,y,\gamma)$, где $x,y$ – координаты робота на плоскости, а $\gamma$ – угол поворота на ней. Необходимо отметить, что $\gamma$ – величина абсолютная и выражается в градусах. Это значит, что вращение против часовой стрелки после одного оборота будет возвращать значения $\geqslant360\degree$.
Полученная карта и координаты новой позиции передаются объекту RoboViz для вывода на экран.
3) Реализация езды по точкам
Рассмотрим карту, созданную в процессе проезда комнаты роботом. Предположим, что точка А - текущая позиция робота, а B - точка назначения робота. Идея проста - поворачивать до тех пор, пока робот не встанет на курс (прямую AB), затем двигаться по нему, пока это возможно. В случае препятствия передавать управления алгоритму из первой работы. Необходимо отметить, что прямая перестраивается каждый раз с получением данных от сенсоров. BreezySLAM третьей координатой задает угол поворота робота, удобно найти угол между AB и осью абсцисс, затем использовать разницу между этим углом и углом робота для ПИД-регулятора.
![Предполагаемый курс движения робота к точке](/pics/path.png)
Для каждой точки известны координаты $A(x_1,y_1)$ и $B(x_2,y_2)$, тогда уравнение прямой, проходящей через две точки будет следующим:
$$\frac{y_1-y_2}{x_1-x_2}*x+\frac{x_1 y_2-x_2 y_1}{x_1-x_2}=y\quad(1)$$
Уравнение для оси абсцисс можно построить аналогично (1) (например для $(0, 0)$ и $(5, 0))$ $0*x+5*y=0$.  
Тангенс угла между прямыми можно найти как:
$$tan⁡β=\left|\frac{k_1-k_2}{1+k_1 k_2}\right|,\quad(2)$$
где $k_1$ и $k_2$ - угловые коэффициенты прямых. $k_2=0→\tan⁡(\beta)=|k_1|$, тогда $\beta=\arctan⁡|k_1|.$ Следом можно узнать значение $\in [0\degree, 360\degree]$, поняв, в какой четверти находится точка назначения.
После нахождения требуемого угла, найдем разницу $\Delta=\gamma-\beta$, где $\gamma$- текущий угол поворота робота. Для того, чтобы робот следовал курсу можно воспользоваться ПИД-регулятором из первой работы. К существующему алгоритму необходимо добавить несколько условий:
    - если передний и боковой сенсоры не регистрируют препятствий, тогда используем прямую AB как целевую, то есть в регулятор будет передаваться значение $\rho+\mu*\Delta$, где $\rho$ - требуемая дистанция справа из первой работы, $\mu$ - коэффициент регулирования для поддержания требуемого угла (было выбрано значение $0.0005$);
    - если препятствие есть спереди, тогда по прямой AB робот уже двигаться не может то, в какую сторону повернет робот будет зависеть от значения $\mu$, если оно большое, тогда минимальное отклонение заставит робота возвращаться на прямую и только очень близкое препятствие спереди заставит его свернуть, а если оно будет слишком маленькое, тогда робот будет возвращаться на прямую только после внушительного поворота;
    - если есть данные со всех сенсоров, тогда регуляция будет производится для минимума из их значений.
